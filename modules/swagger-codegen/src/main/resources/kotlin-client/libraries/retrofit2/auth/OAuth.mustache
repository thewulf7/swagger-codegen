package {{invokerPackage}}.auth;

import java.net.HttpURLConnection.HTTP_UNAUTHORIZED
import java.net.HttpURLConnection.HTTP_FORBIDDEN
import java.io.IOException

import org.apache.oltu.oauth2.client.OAuthClient
import org.apache.oltu.oauth2.client.request.OAuthBearerClientRequest
import org.apache.oltu.oauth2.client.request.OAuthClientRequest
import org.apache.oltu.oauth2.client.request.OAuthClientRequest.AuthenticationRequestBuilder
import org.apache.oltu.oauth2.client.request.OAuthClientRequest.TokenRequestBuilder
import org.apache.oltu.oauth2.client.response.OAuthJSONAccessTokenResponse
import org.apache.oltu.oauth2.common.exception.OAuthProblemException
import org.apache.oltu.oauth2.common.exception.OAuthSystemException
import org.apache.oltu.oauth2.common.message.types.GrantType
import org.apache.oltu.oauth2.common.token.BasicOAuthToken

import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Request.Builder
import okhttp3.Response

class OAuth(client:OkHttpClient, requestBuilder:TokenRequestBuilder):Interceptor {

  @Volatile @get:Synchronized @set:Synchronized var accessToken:String

  private val oauthClient:OAuthClient

  var tokenRequestBuilder:TokenRequestBuilder

  var authenticationRequestBuilder:AuthenticationRequestBuilder

  private val accessTokenListener:AccessTokenListener

  interface AccessTokenListener {
    fun notify(token:BasicOAuthToken)
  }

  init{
    this.oauthClient = OAuthClient(OAuthOkHttpClient(client))
    this.tokenRequestBuilder = requestBuilder
  }

  constructor(requestBuilder:TokenRequestBuilder) : this(OkHttpClient(), requestBuilder) {}

  constructor(flow:OAuthFlow, authorizationUrl:String, tokenUrl:String, scopes:String) : this(OAuthClientRequest.tokenLocation(tokenUrl).setScope(scopes)) {
    setFlow(flow)
    authenticationRequestBuilder = OAuthClientRequest.authorizationLocation(authorizationUrl)
  }

  fun setFlow(flow:OAuthFlow) {
    when (flow) {
      accessCode, implicit -> tokenRequestBuilder.setGrantType(GrantType.AUTHORIZATION_CODE)
      password -> tokenRequestBuilder.setGrantType(GrantType.PASSWORD)
      application -> tokenRequestBuilder.setGrantType(GrantType.CLIENT_CREDENTIALS)
      else -> {}
    }
  }

  @Throws(IOException::class)
  fun intercept(chain:Chain):Response {
    return retryingIntercept(chain, true)
  }

  @Throws(IOException::class)
  private fun retryingIntercept(chain:Chain, updateTokenAndRetryOnAuthorizationFailure:Boolean):Response {
    val request = chain.request()
    // If the request already have an authorization (eg. Basic auth), do nothing
    if (request.header("Authorization") != null)
    {
      return chain.proceed(request)
    }
    // If first time, get the token
    val oAuthRequest:OAuthClientRequest
    if (accessToken == null)
    {
      updateAccessToken(null!!)
    }
    if (accessToken != null)
    {
      // Build the request
      val rb = request.newBuilder()
      val requestAccessToken = String(accessToken)
      try
      {
        oAuthRequest = OAuthBearerClientRequest(request.url().toString())
        .setAccessToken(requestAccessToken)
        .buildHeaderMessage()
      }
      catch (e:OAuthSystemException) {
        throw IOException(e)
      }
      for (header in oAuthRequest.getHeaders().entrySet())
      {
        rb.addHeader(header.key, header.value)
      }
      rb.url(oAuthRequest.getLocationUri())
      //Execute the request
      val response = chain.proceed(rb.build())
      // 401/403 most likely indicates that access token has expired. Unless it happens two times in a row.
      if (response != null && (response.code() === HTTP_UNAUTHORIZED || response.code() === HTTP_FORBIDDEN) && updateTokenAndRetryOnAuthorizationFailure)
      {
        if (updateAccessToken(requestAccessToken))
        {
          return retryingIntercept(chain, false)
        }
      }
      return response
    }
    else
    {
      return chain.proceed(chain.request())
    }
  }

  /*
   * Returns true if the access token has been updated
   */
  @Synchronized
  @Throws(IOException::class)
  fun updateAccessToken(requestAccessToken:String):Boolean {
    if (accessToken == null || accessToken == requestAccessToken)
    {
      try
      {
        val accessTokenResponse = oauthClient.accessToken(this.tokenRequestBuilder.buildBodyMessage())
        if (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null)
        {
          accessToken = accessTokenResponse.getAccessToken()
          if (accessTokenListener != null)
          {
            accessTokenListener.notify(accessTokenResponse.getOAuthToken() as BasicOAuthToken)
          }
          return accessToken != requestAccessToken
        }
        else
        {
          return false
        }
      }
      catch (e:OAuthSystemException) {
        throw IOException(e)
      }
      catch (e:OAuthProblemException) {
        throw IOException(e)
      }
    }
    return true
  }

  fun registerAccessTokenListener(accessTokenListener:AccessTokenListener) {
    this.accessTokenListener = accessTokenListener
  }

}
